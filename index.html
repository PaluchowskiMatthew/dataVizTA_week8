<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<script src="http://d3js.org/d3.v4.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<style type="text/css">

body {
	font: 11px sans-serif;
}
        
.canton {
  fill: #bbb;
}

.canton-boundary {
  fill: none;
  stroke: #fff;
  stroke-linejoin: round;
}

</style>
</head>
<body>
<script type="text/javascript">
		
//Width and height of map
var width = 960;
var height = 700;

// D3 Projection
var projection = d3.geoAlbers()
    .rotate([0, 0])
    .center([8.3, 46.8])
    .scale(16000)
    .translate([width / 2, height / 2])
    .precision(.1);
        
// Define path generator
var path = d3.geoPath()               // path generator that will convert GeoJSON to SVG paths
		  	 .projection(projection);

		
var color = d3.scaleLinear()
			  .range(["rgb(213,222,217)","rgb(69,173,168)","rgb(84,36,55)","rgb(217,91,67)"]);

var svg = d3.select("body")
			.append("svg")
			.attr("width", width)
			.attr("height", height);
        
// Append Div for tooltip to SVG
var div = d3.select("body")
		    .append("div")   
    		.style("opacity", 0);


d3.csv("cantons-population.csv", function(data) {
color.domain([0,1,2,3]); // setting the range of the input data

d3.json("ch-cantons.json", function(json) {
var cantons = topojson.feature(json, json.objects.cantons);
// Loop through each state data value in the .csv file
for (var i = 0; i < data.length; i++) {

	// Grab State Name
	var dataState = data[i].state;

	// Grab data value 
	var dataValue = data[i].visited;

	// Find the corresponding state inside the GeoJSON
	// console.log(json.objects.cantons.geometries[0].properties.abbr)
	// console.log(json.objects.cantons.geometries.length)
	for (var j = 0; j < cantons.features.length; j++)  {
		var jsonState = cantons.features[j].id;

		if (dataState == jsonState) {

		// Copy the data value into the JSON
		cantons.features[j].properties.visited = dataValue; 

		// Stop looking through the JSON
		break;
		}
	}
}

// Bind the data to the SVG and create one path per GeoJSON feature
// svg.selectAll("path")
// 	.data(cantons)
// 	.enter()
// 	.append("path")
// 	.attr("d", path)
// 	.style("stroke", "#fff")
// 	.style("stroke-width", "1")
// 	.style("fill", function(d) {

// 	// Get data value
// 	var value = d.properties.visited;

// 	if (value) {
// 	//If value exists…
// 	return color(value);
// 	} else {
// 	//If value is undefined…
// 	return "rgb(213,222,217)";
// 	}
// });
// 	.style("fill", function(d) {

// 	// Get data value
// 	var value = d.properties.visited;

// 	if (value) {
// 	//If value exists…
// 	return color(value);
// 	} else {
// 	//If value is undefined…
// 	return "rgb(213,222,217)";
// 	}
// });

  svg.append("path")
      .datum(cantons)
      .attr("class", "canton")
      .attr("d", path);
      

  svg.append("path")
      .datum(topojson.mesh(json, json.objects.cantons, function(a, b) { return a !== b; }))
      .attr("class", "canton-boundary")
      .attr("d", path);

  svg.selectAll("text")
      .data(cantons.features)
    .enter().append("text")
      .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; })
      .attr("dy", ".35em")
      .text(function(d) { return d.properties.name; });




// svg.append("path")
//       .datum(cantons)
//       .attr("class", "canton")
//       .attr("d", path);

//   svg.append("path")
//       .datum(topojson.mesh(json, json.objects.cantons, function(a, b) { return a !== b; }))
//       .attr("class", "canton-boundary")
//       .attr("d", path);

		 
// Map the cities I have lived in!
d3.csv("locations.csv", function(data) {

svg.selectAll("circle")
	.data(data)
	.enter()
	.append("circle")
	.attr("cx", function(d) {
		return projection([d.lon, d.lat])[0];
	})
	.attr("cy", function(d) {
		return projection([d.lon, d.lat])[1]+13;
	})
	.attr("r", 1)
		.style("fill", "rgb(217,91,67)")	
		.style("opacity", 0.85)	

    // fade out tooltip on mouse out               
    // .on("mouseout", function(d) {       
    //     div.transition()        
    //        .duration(500)      
    //        .style("opacity", 0);   
    // });
});  
	});

});
</script>
</body>
</html>
